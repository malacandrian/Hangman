<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Hangman : Solving Hangman" />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Hangman</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/malacandrian/Hangman">View on GitHub</a>

          <h1 id="project_title">Hangman</h1>
          <h2 id="project_tagline">Solving Hangman</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/malacandrian/Hangman/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/malacandrian/Hangman/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>
<a name="what-is-the-best-word-to-choose-when-playing-hangman" class="anchor" href="#what-is-the-best-word-to-choose-when-playing-hangman"><span class="octicon octicon-link"></span></a>What is the best word to choose when playing hangman?</h1>

<p>This is the question we're trying to answer, but first we need to ask some better ones.</p>

<ul>
<li>How do we define a "Good word"?</li>
<li> What makes one word better than another?</li>
</ul><h2>
<a name="the-game" class="anchor" href="#the-game"><span class="octicon octicon-link"></span></a>The Game</h2>

<p>Before we begin answering these questions we need to establish what the game is, and how it is best played</p>

<h3>
<a name="the-rules" class="anchor" href="#the-rules"><span class="octicon octicon-link"></span></a>The Rules</h3>

<ol>
<li>The game chooses a secret word  and tells the player its length</li>
<li>Each turn the player can either

<ul>
<li>Ask the game if the word contains a character

<ul>
<li>If it does, the player is told which position(s) the character lies in</li>
<li>If it does not, the player loses 1 life.</li>
<li>If the player loses 10 lives, they lose</li>
</ul>
</li>
<li>Guess what the word is

<ul>
<li>If the player is correct, they win </li>
<li>If the player is incorrect, they lose</li>
</ul>
</li>
</ul>
</li>
</ol><h3>
<a name="strategy" class="anchor" href="#strategy"><span class="octicon octicon-link"></span></a>Strategy</h3>

<p>Because penalties are only incurred for incorrect guesses, the optimal strategy is not to eliminate as large a portion of potential words as possible, but rather to make as few incorrect guesses as possible. This can be achieved by always selecting the character that appears in the most words that are still possible in a given game state. </p>

<p>e.g. Given the game state "a _ _ u _ e" Incorrect letters: c, d</p>

<p>The possible remaining words are : abjure, allure, ampule, arouse, assume, assure, astute, attune</p>

<p>The unguessed characters appear with the following frequencies b-1, j-1, l-2, m-2, n-1, o-1, p-1, r-3, s-4, t-2</p>

<p>Therefore, our next best guess is 's'. When this gives us the pattern "as _ u _ e" this only leaves "astute", therefore the word is solved.</p>

<p>This requires a level of calculation that is not possible for a human to perform during a standard game of hangman, instead the <a href="http://norvig.com/mayzner.html">standard distribution of characters in English</a> can be used as an approximation. That is, always choose the characters in the following order etaoinsrhldcumfpgwybvkxjqz </p>

<p>These two strategies will be referred to as the <strong>Optimal Strategy</strong> and the <strong>Easy Strategy</strong> respectively.</p>

<h2>
<a name="how-do-we-define-a-good-word" class="anchor" href="#how-do-we-define-a-good-word"><span class="octicon octicon-link"></span></a>How do we define a "Good Word"?</h2>

<p>A good word is a word that is hard to guess. A hard to guess word takes a large number of attempts before the word is calculated. Because the player is only penalised for mistakes we want a word that will cause the player to make a large number of incorrect guesses. Finally, because the player only gets 10 lives, and will therefore be making a guess at 9 incorrect characters we want there to be as many open options at that point as possible.</p>

<p>Therefore, the metrics we will be ranking the words on are</p>

<ul>
<li>Number of guesses required</li>
<li>Number of incorrect guesses required</li>
<li>How many possibilities there are after 9 incorrect characters</li>
</ul><h2>
<a name="what-makes-one-word-better-than-another" class="anchor" href="#what-makes-one-word-better-than-another"><span class="octicon octicon-link"></span></a>What makes one word better than another?</h2>

<p>Instinctively we tend to choose long words when we want to make the game harder. The two key reasons I can see for this are</p>

<ul>
<li>Reduced word familiarity</li>
<li>More letters means more guessing</li>
</ul><p>Because the program is familiar with the entire dictionary it has been given the second is not a factor we can study, though as it is poor sportsmanship to choose a word no one else has heard of this is not a problem. As any given character only needs to be guessed once no matter how frequently it appears a high number of unique characters should be used. The final tactic that should jump out upon examining the player's strategy is to choose rare letters, as they are less likely to guess them.</p>

<h2>
<a name="collecting-the-data" class="anchor" href="#collecting-the-data"><span class="octicon octicon-link"></span></a>Collecting the data</h2>

<p>A program was written to test <a href="http://www.mieliestronk.com/corncob_lowercase.txt">a list of over 58000 words</a> (henceforth reffered to as "the dictionary") on both the easy and optimal strategies, outputting its results as a CSV, Excel and PowerPivot were then used to analyse the results.</p>

<h3>
<a name="the-program" class="anchor" href="#the-program"><span class="octicon octicon-link"></span></a>The Program</h3>

<p>At each step the program generates a Regex pattern to represent the current information about the word (in the example above it would have generated <code>^a[^acdeu][^acdeu]u[^acdeu]e$</code>). It then checks this against all remaining words to find the current set of possible words. If there is ever only one word in this set the problem has been solved. The process is performed twice, once using the easy strategy then again using the optimal one.</p>

<p>The program was written in C# across two main classes: <code>Word.cs</code> allows the words to be queried as to their contents, remembers what has been guessed, and creates the Regex patterns. <code>WordTester.cs</code> maintains the list of possible words and chooses the next character to guess at each step, as well as reporting when the word has been solved.</p>

<p><em>The source code is available, though if you want to run it yourself it should be noted that it performs an O(n^2) operation on the dictionary, so takes a while. About 4 hours/run on my laptop.</em></p>

<h2>
<a name="the-results" class="anchor" href="#the-results"><span class="octicon octicon-link"></span></a>The results</h2>

<h3>
<a name="what-makes-a-word-bad" class="anchor" href="#what-makes-a-word-bad"><span class="octicon octicon-link"></span></a>What makes a word bad?</h3>

<p>Before we start answering this question it's worth looking at factors we thought would help but either have no affect, or actually make the word easier to guess.</p>

<h4>
<a name="length" class="anchor" href="#length"><span class="octicon octicon-link"></span></a>Length</h4>

<p>One of the most surprising results is that long words are easier to guess than shorter ones. Despite being longer, they require fewer guesses to discern the word, and incur many fewer mistakes.</p>

<p>!!!GRAPH 1 - Word difficulty against length!!!</p>

<p>As the word length increases the number of possible arrangements increases much faster than the number of words increases (see the below graphs). This means that for any given pattern there are fewer words that match it as word length increases.</p>

<p>!!!Graph: Word lengths
!!!Graph: Word space use</p>

<p>e.g. "Onomatopoeia" is a 12 letter word with 8 unique characters. There are 3102 possible 12 letter words in the dictionary (about 5%), with "i" the most common character among them. Plugging this in gives the pattern <code>"_ _ _ _ _ _ _ _ _ _ i _"</code>, which only 67 words match. We're now down to 2% of 12 letter words, or 0.1% of the dictionary in 1 guess. The next guess is "o" giving us a pattern of <code>"o _ o _ _ _ o _ o _ i _"</code> which is only matched by "onomatopoeia".</p>

<p>Playing against the easy strategy, the word contains the 6 most common characters, and after 3 (e, t, a) produces the pattern <code>"_ _ _ _ at _ _ _ e _ a"</code> which again can only be matched by "onomatopoeia".</p>

<h3>
<a name="unique-characters" class="anchor" href="#unique-characters"><span class="octicon octicon-link"></span></a>Unique Characters</h3>

<p>Furthermore, having a high proportion of unique characters appears to have no discernible effect on word guess-ability, while high number of them makes the words easier to guess</p>

<p>!!!GRAPH - Word diffuclty against unique chars!!!</p>

<p>This should have been obvious: we want the player to make mistakes. The greater the number of unique characters in the word, the fewer mistakes the player can make, the higher the probability that they will get one right. </p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Hangman maintained by <a href="https://github.com/malacandrian">malacandrian</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
