<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Hangman : Solving Hangman" />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Hangman</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/malacandrian/Hangman">View on GitHub</a>

          <h1 id="project_title">Hangman</h1>
          <h2 id="project_tagline">Solving Hangman</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/malacandrian/Hangman/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/malacandrian/Hangman/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>
<a name="what-is-the-best-word-to-choose-when-playing-hangman" class="anchor" href="#what-is-the-best-word-to-choose-when-playing-hangman"><span class="octicon octicon-link"></span></a>What is the best word to choose when playing hangman?</h1>

<p>This is the question we're trying to answer, but first we need to ask some better ones.</p>

<ul>
<li>How do we define a "Good word"?</li>
<li> What makes one word better than another?</li>
</ul><h2>
<a name="the-game" class="anchor" href="#the-game"><span class="octicon octicon-link"></span></a>The Game</h2>

<p>Before we begin answering these questions we need to establish what the game is, and how it is best played</p>

<h3>
<a name="the-rules" class="anchor" href="#the-rules"><span class="octicon octicon-link"></span></a>The Rules</h3>

<ol>
<li>The game chooses a secret word  and tells the player its length</li>
<li>Each turn the player can either

<ul>
<li>Ask the game if the word contains a character

<ul>
<li>If it does, the player is told which position(s) the character lies in</li>
<li>If it does not, the player loses 1 life.</li>
<li>If the player loses 10 lives, they lose</li>
</ul>
</li>
<li>Guess what the word is

<ul>
<li>If the player is correct, they win </li>
<li>If the player is incorrect, they lose
###Strategy
Because penalties are only incurred for incorrect guesses, the optimal strategy is not to eliminate as large a portion of potential words as possible, but rather to make as few incorrect guesses as possible. This can be achieved by always selecting the character that appears in the most words that are still possible in a given game state.</li>
</ul>
</li>
</ul>
</li>
</ol><p>e.g. Given the game state "a _ _ u _ e" Incorrect letters: c, d</p>

<p>The possible remaining words are : abjure, allure, ampule, arouse, assume, assure, astute, attune</p>

<p>The unguessed characters appear with the following frequencies b-1, j-1, l-2, m-2, n-1, o-1, p-1, r-3, s-4, t-2</p>

<p>Therefore, our next best guess is 's'. When this gives us the pattern "as _ u _ e" this only leaves "astute", therefore the word is solved.</p>

<p>This requires a level of calculation that is not possible for a human to perform during a standard game of hangman, instead the <a href="http://norvig.com/mayzner.html">standard distribution of characters in English</a> can be used as an approximation. That is, always choose the characters in the following order etaoinsrhldcumfpgwybvkxjqz </p>

<p>These two strategies will be referred to as the <strong>Optimal Strategy</strong> and the <strong>Easy Strategy</strong> respectively.</p>

<h2>
<a name="how-do-we-define-a-good-word" class="anchor" href="#how-do-we-define-a-good-word"><span class="octicon octicon-link"></span></a>How do we define a "Good Word"?</h2>

<p>A good word is a word that is hard to guess. A hard to guess word takes a large number of attempts before the word is calculated. Because the player is only penalised for mistakes we want a word that will cause the player to make a large number of incorrect guesses. Finally, because the player only gets 10 lives, and will therefore be making a guess at 9 incorrect characters we want there to be as many open options at that point as possible.</p>

<p>Therefore, the metrics we will be ranking the words on are</p>

<ul>
<li>Number of guesses required</li>
<li>Number of incorrect guesses required</li>
<li>How many possibilities there are after 9 incorrect characters</li>
</ul><h2>
<a name="what-makes-one-word-better-than-another" class="anchor" href="#what-makes-one-word-better-than-another"><span class="octicon octicon-link"></span></a>What makes one word better than another?</h2>

<p>It is prudent to wait</p>

<h2>
<a name="collecting-the-data" class="anchor" href="#collecting-the-data"><span class="octicon octicon-link"></span></a>Collecting the data</h2>

<p>A program was written to test <a href="http://www.mieliestronk.com/corncob_lowercase.txt">a list of over 58000 words</a> on both the easy and optimal strategies, outputting its results as a CSV, Excel was then used to analyse the results.</p>

<h3>
<a name="the-program" class="anchor" href="#the-program"><span class="octicon octicon-link"></span></a>The Program</h3>

<p>At each step the program generates a Regex pattern to represent the current information about the word (in the example above it would have generated <code>^a[^acdeu][^acdeu]u[^acdeu]e\r</code>). It then checks this against all remaining words to find the current set of possible words. If there is ever only one word in this set the problem has been solved. The process is performed twice, once using the easy strategy then again using the optimal one.</p>

<p>The program was written in C# across two main classes: <code>Word.cs</code> allows the words to be queried as to their contents, remembers what has been guessed, and creates the Regex patterns. <code>WordTester.cs</code> maintains the list of possible words and chooses the next character to guess at each step, as well as reporting when the word has been solved.</p>

<p><em>The source code is available, though if you want to run it yourself it should be noted that it performs an O(n^2) operation on the dictionary, so takes a while. About 4 hours/run on my laptop.</em></p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Hangman maintained by <a href="https://github.com/malacandrian">malacandrian</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
